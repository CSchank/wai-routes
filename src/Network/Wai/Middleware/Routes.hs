{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeSynonymInstances, FlexibleInstances #-}
{- |
Module      :  Network.Wai.Middleware.Routes
Copyright   :  (c) Anupam Jain 2011
License     :  GNU GPL Version 3 (see the file LICENSE)

Maintainer  :  ajnsit@gmail.com
Stability   :  experimental
Portability :  non-portable (uses ghc extensions)

This package provides typesafe URLs for Wai applications.
-}
module Network.Wai.Middleware.Routes
    -- QQ Parsing of routes
    ( parseRoutes
    , parseRoutesFile
    , parseRoutesNoCheck
    , parseRoutesFileNoCheck

    -- TH function to generate Routable instance
    , mkRoute
    , Routable(..)

    -- Internal class needed by TH
    , RenderRoute(..)

    -- The Route datatype generated by TH
    , Route(..)

    -- The type of the Handlers
    , Handler

    -- Dispatching function
    , dispatch

    -- Route -> Text conversion
    , showRoute
    )
    where

-- Wai
import Network.Wai (Middleware, Application, pathInfo, requestMethod)
import Network.HTTP.Types (StdMethod(GET), parseMethod)

-- Yesod Routes
import Yesod.Routes.Class (Route, RenderRoute(..))
import Yesod.Routes.Parse (parseRoutes, parseRoutesNoCheck, parseRoutesFile, parseRoutesFileNoCheck, parseType)
import Yesod.Routes.TH (mkRenderRouteInstance, mkDispatchClause, ResourceTree(..))

-- Text
import qualified Data.Text as T
import Data.Text (Text)

-- TH
import Language.Haskell.TH.Syntax

-- Generate RenderRoute instance and Dispatcher
mkRoute :: String -> [ResourceTree String] -> Q [Dec]
mkRoute typName routes = do
  let typ = parseType typName
  inst <- mkRenderRouteInstance typ $ map (fmap parseType) routes
  dispatch <- mkDispatchClause [|runHandler|] [|dispatcher|] [|id|] routes
  return $ InstanceD []
          (ConT ''Routable `AppT` typ)
          [FunD (mkName "dispatcher") [dispatch]]
        : inst

type Handler master = master -> Application

runHandler
  :: Handler master
  -> master
  -> master
  -> Maybe (Route master)
  -> (Route master -> Route master)
  -> Handler master
runHandler h _ _ _ _ = h

-- Classes for dispatching
-- Generated by mkRoute
class Routable master where
  dispatcher
    :: master
    -> master
    -> (Route master -> Route master)
    -> Handler master -- 404 page
    -> (Route master -> Handler master) -- 405 page
    -> Text -- method
    -> [Text]
    -> Handler master

-- | The application dispatcher function.
dispatch :: Routable master => master -> Middleware
dispatch master def req = app master req
  where
    app = dispatcher master master id def404 def405 (T.pack $ show $ method req) (pathInfo req)
    def404 = const def
    def405 = const $ const def -- TODO: This should ideally NOT pass on handling to the next resource
    method req' = case parseMethod $ requestMethod req' of
      Right m -> m
      Left  _ -> GET

-- Route -> Text conversion
-- TODO: Verify that intercalate "/" is sufficient and correct for all cases
-- HACK: We add a '/' to the front of the URL (by adding an empty piece at
-- the front of the url [Text]) to make everything relative to the root.
-- This ensures that the links always work.
showRoute :: RenderRoute master => Route master -> Text
showRoute = T.intercalate (T.pack "/") . (T.pack "" :) . fst . renderRoute

